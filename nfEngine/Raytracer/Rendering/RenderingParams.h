#pragma once

#include "Counters.h"

#include "../Traversal/RayPacket.h"
#include "../Traversal/HitPoint.h"
#include "../Color/RayColor.h"
#include "../Sampling/GenericSampler.h"
#include "../../nfCommon/Math/Random.hpp"
#include "../../nfCommon/Containers/UniquePtr.hpp"
#include "../../nfCommon/Memory/Aligned.hpp"
#include "../../nfCommon/Reflection/ReflectionClassDeclare.hpp"
#include "../../nfCommon/Reflection/ReflectionEnumMacros.hpp"

namespace NFE {
namespace RT {

using RendererContextPtr = Common::UniquePtr<IRendererContext>;

enum class TraversalMode : uint8
{
    Single = 0,
    Packet,
};

enum class LightSamplingStrategy : uint8
{
    Single,
    All,
    // TODO "Importance Sampling of Many Lights with Adaptive Tree Splitting"
};

struct AdaptiveRenderingSettings
{
    NFE_DECLARE_CLASS(AdaptiveRenderingSettings);

public:
    bool enable = false;
    uint16 numInitialPasses = 10;
    uint16 minBlockSize = 4;
    uint16 maxBlockSize = 256;
    float subdivisionTreshold = 0.005f;
    float convergenceTreshold = 0.0001f;
};

struct SamplingParams
{
    NFE_DECLARE_CLASS(SamplingParams);

public:
    // Number of sample dimensions generated by low-discrepancy sampler
    // Note: If more dimensions is required during integration, uniform random samples will be used
    uint32 dimensions = 64;

    // Enables image-space sample dithering based on blue noise pattern
    bool useBlueNoiseDithering = true;
};

struct RenderingParams
{
    NFE_DECLARE_CLASS(RenderingParams);

public:
    SamplingParams samplingParams;

    // Antialiasing factor
    // Setting to higher values will blur the image
    float antiAliasingSpread = 0.5f;

    // Motion blur multiplier
    // NOTE: must be in [0...1] range
    float motionBlurStrength = 0.5f;

    // maximum ray depth
    uint32 maxRayDepth = 20;

    // ray depth at which Russian Roulette algorithm kicks in
    uint32 minRussianRouletteDepth = 1;

    // rendering tile dimensions (tiles are processed as a tasks in thread pool in parallel)
    uint16 tileSize = 32;

    // select mode of ray traversal
    TraversalMode traversalMode = TraversalMode::Single;

    // describes how lights should be sampled
    LightSamplingStrategy lightSamplingStrategy = LightSamplingStrategy::Single;

    // generate image which represents time per pixel (in milliseconds)
    // instead of regular rays color image
    bool visualizeTimePerPixel = false;

    // adaptive rendering settings
    AdaptiveRenderingSettings adaptiveSettings;
};

} // namespace RT
} // namespace NFE

NFE_DECLARE_ENUM_TYPE(NFE::RT::TraversalMode);
NFE_DECLARE_ENUM_TYPE(NFE::RT::LightSamplingStrategy);
