/**
 * @file
 * @author Witek902 (witek902@gmail.com)
 * @brief  VertexBuffersScene definition
 */

#include "../PCH.hpp"

#include "Scene.hpp"

#include "Engine/Common/Math/Random.hpp"
#include "Engine/Renderers/RendererCommon/Fence.hpp"
#include "Engine/Common/Reflection/ReflectionClassDefine.hpp"


class VertexBuffersScene : public Scene
{
    NFE_DECLARE_POLYMORPHIC_CLASS(VertexBuffersScene)

    struct InstanceData
    {
        NFE::Math::Vec3f pos;
        NFE::Math::Vec4fU color;
    };

    // Renderer interfaces generated by VertexBuffersScene

    NFE::Renderer::RenderTargetPtr mWindowRenderTarget;

    NFE::Renderer::ShaderPtr mVertexShader;
    NFE::Renderer::ShaderPtr mPixelShader;

    NFE::Renderer::BufferPtr mPositionsVertexBuffer;
    NFE::Renderer::BufferPtr mColorVertexBuffer;
    NFE::Renderer::BufferPtr mInstanceBuffer;
    NFE::Renderer::BufferPtr mIndexBuffer;
    NFE::Renderer::VertexLayoutPtr mVertexLayout;

    NFE::Renderer::PipelineStatePtr mPipelineState;


    // for dynamic vertex buffers
    std::vector<InstanceData> mInstancesData;
    std::vector<NFE::Math::Vec2f> mVelocities;
    NFE::Renderer::ResourceAccessMode mVertexBufferMode;

    // Releases only subscene-related resources. Backbuffer, RT and BlendState stay intact.
    void ReleaseSubsceneResources() override;

    // Resource creators for subscenes
    bool LoadShaders(bool useInstancing);
    bool CreateBuffers(bool withInstanceBuffer, NFE::Renderer::ResourceAccessMode vertexBufferMode);

    // Subscenes
    bool CreateSubSceneSimple();
    bool CreateSubSceneInstancing(NFE::Renderer::ResourceAccessMode vertexBufferMode);

public:
    VertexBuffersScene();
    ~VertexBuffersScene();

    bool OnInit(void* winHandle) override;
    void Draw(float dt) override;
    void Release() override;
};


NFE_DEFINE_POLYMORPHIC_CLASS(VertexBuffersScene)
    NFE_CLASS_PARENT(Scene)
NFE_END_DEFINE_CLASS()


using namespace NFE;
using namespace NFE::Math;
using namespace NFE::Renderer;

namespace {

int gInstancesNumber = 200;

static uint32 gFrameIndex = 0;

} // namespace


bool VertexBuffersScene::LoadShaders(bool useInstancing)
{
    ShaderMacro vsMacro[] = { { "USE_INSTANCING", useInstancing ? "1" : "0" } };
    const Common::String vsPath = gShaderPathPrefix + "InstancingTestVS" + gShaderPathExt;
    mVertexShader = CompileShader(vsPath.Str(), ShaderType::Vertex, vsMacro, 1);
    if (!mVertexShader)
        return false;

    const Common::String psPath = gShaderPathPrefix + "InstancingTestPS" + gShaderPathExt;
    mPixelShader = CompileShader(psPath.Str(), ShaderType::Pixel, nullptr, 0);
    if (!mPixelShader)
        return false;

    return true;
}

bool VertexBuffersScene::CreateBuffers(bool withInstanceBuffer, ResourceAccessMode vertexBufferMode)
{
    /// create vertex buffers
    BufferDesc vbDesc;

    float vbPositionData[] =
    {
        /// vertex structure: pos.xyz
        -0.05f, -0.05f, 0.0f,
         0.05f, -0.05f, 0.0f,
         0.05f,  0.05f, 0.0f,
        -0.05f,  0.05f, 0.0f,
    };

    vbDesc.size = sizeof(vbPositionData);
    vbDesc.usage = BufferUsageFlag::VertexBuffer;
    mPositionsVertexBuffer = mRendererDevice->CreateBuffer(vbDesc);
    if (!mPositionsVertexBuffer)
        return false;


    float vbColorData[] =
    {
        /// vertex structure: color.rgba
        0.5f, 1.0f, 0.5f, 1.0f,
        0.0f, 0.5f, 1.0f, 1.0f,
        1.0f, 0.5f, 0.5f, 1.0f,
        1.0f, 1.0f, 1.0f, 1.0f,
    };

    vbDesc.size = sizeof(vbColorData);
    vbDesc.usage = BufferUsageFlag::VertexBuffer;
    mColorVertexBuffer = mRendererDevice->CreateBuffer(vbDesc);
    if (!mColorVertexBuffer)
        return false;


    /// create index buffer
    uint16 ibData[] =
    {
        0, 1, 2,  // triangle 0
        0, 2, 3,  // triangle 1
    };

    BufferDesc ibDesc;
    ibDesc.size = sizeof(ibData);
    ibDesc.usage = BufferUsageFlag::IndexBuffer;
    mIndexBuffer = mRendererDevice->CreateBuffer(ibDesc);
    if (!mIndexBuffer)
        return false;

    // upload buffer data
    {
        mCommandBuffer->Begin(CommandQueueType::Copy);
        mCommandBuffer->WriteBuffer(mPositionsVertexBuffer, 0, sizeof(vbPositionData), vbPositionData);
        mCommandBuffer->WriteBuffer(mColorVertexBuffer, 0, sizeof(vbColorData), vbColorData);
        mCommandBuffer->WriteBuffer(mIndexBuffer, 0, sizeof(ibData), ibData);
        mCopyQueue->Execute(mCommandBuffer->Finish());
        mCopyQueue->Signal()->Wait();
    }

    /// create vertex layout object
    if (withInstanceBuffer)
    {
        Random random;

        mInstancesData.resize(gInstancesNumber);
        mVelocities.resize(gInstancesNumber);

        for (int i = 0; i < gInstancesNumber; ++i)
        {
            mInstancesData[i].pos.x = random.GetFloatBipolar();
            mInstancesData[i].pos.y = random.GetFloatBipolar();
            mInstancesData[i].pos.z = random.GetFloatBipolar();
            mInstancesData[i].color = random.GetVec4fU();

            mVelocities[i].x = random.GetFloatBipolar();
            mVelocities[i].y = random.GetFloatBipolar();
        }

        mVertexBufferMode = vertexBufferMode;
        vbDesc.mode = vertexBufferMode;
        vbDesc.size = sizeof(InstanceData) * gInstancesNumber;
        vbDesc.usage = BufferUsageFlag::VertexBuffer;
        mInstanceBuffer = mRendererDevice->CreateBuffer(vbDesc);
        if (!mInstanceBuffer)
            return false;

        // upload buffer data
        {
            mCommandBuffer->Begin(CommandQueueType::Copy);
            mCommandBuffer->WriteBuffer(mPositionsVertexBuffer, 0, sizeof(InstanceData) * gInstancesNumber, mInstancesData.data());
            mCopyQueue->Execute(mCommandBuffer->Finish());
            mCopyQueue->Signal()->Wait();
        }

        VertexLayoutElement vertexLayoutElements[] =
        {
            { Format::R32G32B32_Float,       0,  0, false, 0 }, // position
            { Format::R32G32B32A32_Float,    0,  1, false, 0 }, // color
            { Format::R32G32B32_Float,       0,  2, true,  1 }, // position offset
            { Format::R32G32B32A32_Float,    12, 2, true,  1 }, // color scale
        };

        VertexLayoutDesc vertexLayoutDesc;
        vertexLayoutDesc.elements = vertexLayoutElements;
        vertexLayoutDesc.numElements = 4;
        mVertexLayout = mRendererDevice->CreateVertexLayout(vertexLayoutDesc);
    }
    else
    {
        VertexLayoutElement vertexLayoutElements[] =
        {
            { Format::R32G32B32_Float,       0, 0, false, 0 }, // position
            { Format::R32G32B32A32_Float,    0, 1, false, 0 }, // color
        };

        VertexLayoutDesc vertexLayoutDesc;
        vertexLayoutDesc.elements = vertexLayoutElements;
        vertexLayoutDesc.numElements = 2;
        mVertexLayout = mRendererDevice->CreateVertexLayout(vertexLayoutDesc);
    }

    if (!mVertexLayout)
        return false;

    PipelineStateDesc pipelineStateDesc;
    pipelineStateDesc.renderTargetFormats = { Format::R8G8B8A8_U_Norm };
    pipelineStateDesc.vertexShader = mVertexShader;
    pipelineStateDesc.pixelShader = mPixelShader;
    pipelineStateDesc.primitiveType = PrimitiveType::Triangles;
    pipelineStateDesc.vertexLayout = mVertexLayout;
    pipelineStateDesc.raterizerState.cullMode = CullMode::Disabled;
    mPipelineState = mRendererDevice->CreatePipelineState(pipelineStateDesc);
    if (!mPipelineState)
        return false;

    return true;
}

/////////////////
/// Subscenes ///
/////////////////

bool VertexBuffersScene::CreateSubSceneSimple()
{
    gFrameIndex = 0;

    if (!LoadShaders(false))
        return false;

    if (!CreateBuffers(false, ResourceAccessMode::GPUOnly))
        return false;

    return true;
}

bool VertexBuffersScene::CreateSubSceneInstancing(ResourceAccessMode vertexBufferMode)
{
    gFrameIndex = 0;

    if (!LoadShaders(true))
        return false;

    if (!CreateBuffers(true, vertexBufferMode))
        return false;

    return true;
}

/////////////////////////////////////////////////////////
/// VertexBuffersScene methods and virtuals overridden ///
/////////////////////////////////////////////////////////

VertexBuffersScene::VertexBuffersScene()
    : Scene("VertexBuffers")
{
    RegisterSubScene(std::bind(&VertexBuffersScene::CreateSubSceneSimple, this),
                     "Simple: Static vertex buffer (2 vertex buffers)");
    RegisterSubScene(std::bind(&VertexBuffersScene::CreateSubSceneInstancing, this, ResourceAccessMode::GPUOnly),
                     "Instancing: Dynamic vertex buffer (3 vertex buffers)");
    RegisterSubScene(std::bind(&VertexBuffersScene::CreateSubSceneInstancing, this, ResourceAccessMode::Volatile),
                     "Instancing: Volatile vertex buffer (3 vertex buffers)");
}

VertexBuffersScene::~VertexBuffersScene()
{
    Release();
}

void VertexBuffersScene::ReleaseSubsceneResources()
{
    Scene::ReleaseSubsceneResources();

    // clear resources

    mPositionsVertexBuffer.Reset();
    mColorVertexBuffer.Reset();
    mInstanceBuffer.Reset();
    mIndexBuffer.Reset();
    mVertexLayout.Reset();
    mPipelineState.Reset();

    mPixelShader.Reset();
    mVertexShader.Reset();
}

bool VertexBuffersScene::OnInit(void* winHandle)
{
    if (!Scene::OnInit(winHandle))
    {
        return false;
    }

    // create rendertarget that will render to the window's backbuffer
    RenderTargetDesc rtDesc;
    rtDesc.targets = { RenderTargetElement(mWindowRenderTargetTexture) };
    mWindowRenderTarget = mRendererDevice->CreateRenderTarget(rtDesc);
    if (!mWindowRenderTarget)
        return false;

    return true;
}

void VertexBuffersScene::Draw(float dt)
{
    // reset bound resources and set them once again
    mCommandBuffer->Begin(CommandQueueType::Graphics);
    mCommandBuffer->SetViewport(0.0f, static_cast<float>(WINDOW_WIDTH), 0.0f,
                                static_cast<float>(WINDOW_HEIGHT), 0.0f, 1.0f);
    mCommandBuffer->SetScissors(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);
    mCommandBuffer->SetRenderTarget(mWindowRenderTarget);

    mCommandBuffer->SetPipelineState(mPipelineState);

    mCommandBuffer->SetIndexBuffer(mIndexBuffer, IndexBufferFormat::Uint16);

    if (mInstanceBuffer)
    {
        const BufferPtr vertexBuffers[] = { mPositionsVertexBuffer, mColorVertexBuffer, mInstanceBuffer };
        uint32 strides[] = { 3 * sizeof(float), 4 * sizeof(float), sizeof(InstanceData) };
        uint32 offsets[] = { 0, 0, 0 };
        mCommandBuffer->SetVertexBuffers(3, vertexBuffers, strides, offsets);

        // update dynamic/volatile buffer
        if (mVertexBufferMode == ResourceAccessMode::GPUOnly || mVertexBufferMode == ResourceAccessMode::Volatile)
        {
            for (int i = 0; i < gInstancesNumber; ++i)
            {
                const float velocity = 0.3f;
                mInstancesData[i].pos.x += (velocity * dt) * mVelocities[i].x;
                mInstancesData[i].pos.y += (velocity * dt) * mVelocities[i].y;

                if (mInstancesData[i].pos.x > 1.0f || mInstancesData[i].pos.x < -1.0f)
                    mVelocities[i].x = -mVelocities[i].x;

                if (mInstancesData[i].pos.y > 1.0f || mInstancesData[i].pos.y < -1.0f)
                    mVelocities[i].y = -mVelocities[i].y;
            }

            mCommandBuffer->WriteBuffer(mInstanceBuffer, 0, sizeof(InstanceData) * gInstancesNumber, mInstancesData.data());
        }
    }
    else
    {
        const BufferPtr vertexBuffers[] = { mPositionsVertexBuffer, mColorVertexBuffer };
        uint32 strides[] = { 3 * sizeof(float), 4 * sizeof(float) };
        uint32 offsets[] = { 0, 0 };
        mCommandBuffer->SetVertexBuffers(2, vertexBuffers, strides, offsets);
    }

    if (gFrameIndex == 0)
    {
        // clear target
        const Vec4fU color(0.0f, 0.0f, 0.0f, 1.0f);
        mCommandBuffer->Clear(ClearFlagsColor, 1, nullptr, &color);
    }

    // draw
    if (mInstanceBuffer)
        mCommandBuffer->DrawIndexed(6, gInstancesNumber);
    else
        mCommandBuffer->DrawIndexed(6);

    mCommandBuffer->CopyTexture(mWindowRenderTargetTexture, mWindowBackbuffer);

    CommandListPtr commandList = mCommandBuffer->Finish();
    mGraphicsQueue->Execute(commandList);
    mWindowBackbuffer->Present();
    mRendererDevice->FinishFrame();

    gFrameIndex++;
}

void VertexBuffersScene::Release()
{
    ReleaseSubsceneResources();
    mWindowRenderTarget.Reset();
    mWindowBackbuffer.Reset();
    mCommandBuffer.Reset();
    mRendererDevice = nullptr;
}
