/**
 * @file
 * @author Witek902 (witek902@gmail.com)
 * @brief  Definitions of TessellationScene functions
 */

#include "../PCH.hpp"

#include "Scene.hpp"

#include "Engine/Common/Math/Math.hpp"
#include "Engine/Common/Math/Matrix4.hpp"
#include "Engine/Renderers/RendererCommon/Fence.hpp"
#include "Engine/Common/Reflection/ReflectionClassDefine.hpp"


class TessellationScene : public Scene
{
    NFE_DECLARE_POLYMORPHIC_CLASS(TessellationScene)

    // Renderer interfaces generated by BasicScene
    NFE::Renderer::RenderTargetPtr mWindowRenderTarget;
    NFE::Renderer::PipelineStatePtr mPipelineState;

    NFE::Renderer::ShaderPtr mVertexShader;
    NFE::Renderer::ShaderPtr mHullShader;
    NFE::Renderer::ShaderPtr mDomainShader;
    NFE::Renderer::ShaderPtr mPixelShader;

    NFE::Renderer::BufferPtr mVertexBuffer;
    NFE::Renderer::VertexLayoutPtr mVertexLayout;

    // Releases only subscene-related resources. Backbuffer, RT and BlendState stay intact.
    void ReleaseSubsceneResources() override;

    // Resource creators for subscenes
    bool LoadShaders();
    bool CreateVertexBuffer();

    // Subscenes
    bool CreateSubSceneBezierLine();
    // TODO more subscenes testing triangle patches, variable tesselation factor, etc.

public:
    TessellationScene();
    ~TessellationScene();

    bool OnInit(void* winHandle) override;
    void Draw(float dt) override;
    void Release() override;
};


NFE_DEFINE_POLYMORPHIC_CLASS(TessellationScene)
    NFE_CLASS_PARENT(Scene)
NFE_END_DEFINE_CLASS()


using namespace NFE;
using namespace NFE::Math;
using namespace NFE::Renderer;

namespace {

struct VertexCBuffer
{
    Matrix4 viewMatrix;
};

struct PixelCBuffer
{
    Matrix4 viewMatrix;
};

} // namespace

/// Helper creators for the Scene

bool TessellationScene::LoadShaders()
{
    const Common::String vsPath = gShaderPathPrefix + "TessellationVS" + gShaderPathExt;
    mVertexShader = CompileShader(vsPath.Str(), ShaderType::Vertex, nullptr, 0);
    if (!mVertexShader)
        return false;

    const Common::String hsPath = gShaderPathPrefix + "TessellationHS" + gShaderPathExt;
    mHullShader = CompileShader(hsPath.Str(), ShaderType::Hull, nullptr, 0);
    if (!mHullShader)
        return false;

    const Common::String dsPath = gShaderPathPrefix + "TessellationDS" + gShaderPathExt;
    mDomainShader = CompileShader(dsPath.Str(), ShaderType::Domain, nullptr, 0);
    if (!mDomainShader)
        return false;

    const Common::String psPath = gShaderPathPrefix + "TessellationPS" + gShaderPathExt;
    mPixelShader = CompileShader(psPath.Str(), ShaderType::Pixel, nullptr, 0);
    if (!mPixelShader)
        return false;

    return true;
}

bool TessellationScene::CreateVertexBuffer()
{
    // create vertex buffers
    float vbData[] =
    {
        // Bezier curve control points
        -1.0f, -0.8f, 0.0f,
         4.0f, -1.0f, 0.0f,
        -4.0f,  1.0f, 0.0f,
         1.0f,  0.8f, 0.0f,
    };

    BufferDesc vbDesc;
    vbDesc.size = sizeof(vbData);
    vbDesc.usage = BufferUsageFlag::VertexBuffer;
    mVertexBuffer = mRendererDevice->CreateBuffer(vbDesc);
    if (!mVertexBuffer)
        return false;

    // upload buffer data
    {
        mCommandBuffer->Begin(CommandQueueType::Copy);
        mCommandBuffer->WriteBuffer(mVertexBuffer, 0, sizeof(vbData), vbData);
        mCopyQueue->Execute(mCommandBuffer->Finish());
        mCopyQueue->Signal()->Wait();
    }

    VertexLayoutElement vertexLayoutElements[] =
    {
        { Format::R32G32B32_Float, 0, 0, false, 0 }, // position
    };

    VertexLayoutDesc vertexLayoutDesc;
    vertexLayoutDesc.elements = vertexLayoutElements;
    vertexLayoutDesc.numElements = 1;
    mVertexLayout = mRendererDevice->CreateVertexLayout(vertexLayoutDesc);
    if (!mVertexLayout)
        return false;

    PipelineStateDesc pipelineStateDesc;
    pipelineStateDesc.renderTargetFormats = { Format::R8G8B8A8_U_Norm };
    pipelineStateDesc.vertexShader = mVertexShader;
    pipelineStateDesc.pixelShader = mPixelShader;
    pipelineStateDesc.hullShader = mHullShader;
    pipelineStateDesc.domainShader = mDomainShader;
    pipelineStateDesc.blendState.independent = false;
    pipelineStateDesc.blendState.rtDescs[0].enable = true;
    pipelineStateDesc.primitiveType = PrimitiveType::Patch;
    pipelineStateDesc.numControlPoints = 4;
    pipelineStateDesc.vertexLayout = mVertexLayout;
    mPipelineState = mRendererDevice->CreatePipelineState(pipelineStateDesc);
    if (!mPipelineState)
        return false;

    return true;
}

/////////////////
/// Subscenes ///
/////////////////

// Basic initialization, additionally to RT & BackBuffer shaders are compiled
// Empty window should be visible
bool TessellationScene::CreateSubSceneBezierLine()
{
    if (!LoadShaders())
        return false;

    return CreateVertexBuffer();
}


/////////////////////////////////////////////////
/// TessellationScene methods and virtuals overridden ///
/////////////////////////////////////////////////

TessellationScene::TessellationScene()
    : Scene("Tessellation")
{
    RegisterSubScene(std::bind(&TessellationScene::CreateSubSceneBezierLine, this), "BezierLine");
}

TessellationScene::~TessellationScene()
{
    Release();
}

void TessellationScene::ReleaseSubsceneResources()
{
    Scene::ReleaseSubsceneResources();

    // clear resources
    mVertexLayout.Reset();
    mVertexBuffer.Reset();

    mPixelShader.Reset();
    mHullShader.Reset();
    mDomainShader.Reset();
    mVertexShader.Reset();

    mPipelineState.Reset();
}

bool TessellationScene::OnInit(void* winHandle)
{
    if (!Scene::OnInit(winHandle))
    {
        return false;
    }

    // create rendertarget that will render to the window's backbuffer
    RenderTargetDesc rtDesc;
    rtDesc.targets = { RenderTargetElement(mWindowRenderTargetTexture) };
    mWindowRenderTarget = mRendererDevice->CreateRenderTarget(rtDesc);
    if (!mWindowRenderTarget)
        return false;

    return true;
}

void TessellationScene::Draw(float dt)
{
    NFE_UNUSED(dt);

    // reset bound resources and set them once again
    mCommandBuffer->Begin(CommandQueueType::Graphics);
    mCommandBuffer->SetViewport(0.0f, (float)WINDOW_WIDTH, 0.0f, (float)WINDOW_HEIGHT, 0.0f, 1.0f);
    mCommandBuffer->SetScissors(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);
    mCommandBuffer->SetRenderTarget(mWindowRenderTarget);

    uint32 stride = 3 * sizeof(float);
    uint32 offset = 0;

    if (mVertexBuffer)
    {
        const BufferPtr vertexBuffers[] = { mVertexBuffer };
        mCommandBuffer->SetVertexBuffers(1, vertexBuffers, &stride, &offset);
    }

    if (mPipelineState)
        mCommandBuffer->SetPipelineState(mPipelineState);

    mCommandBuffer->SetRenderTarget(mWindowRenderTarget);

    // clear target
    const Vec4fU color(0.0f, 0.0f, 0.0f, 1.0f);
    mCommandBuffer->Clear(ClearFlagsColor, 1, nullptr, &color);

    // draw
    mCommandBuffer->Draw(4, 1);

    mCommandBuffer->CopyTexture(mWindowRenderTargetTexture, mWindowBackbuffer);

    CommandListPtr commandList = mCommandBuffer->Finish();
    mGraphicsQueue->Execute(commandList);
    mWindowBackbuffer->Present();
    mRendererDevice->FinishFrame();
}

void TessellationScene::Release()
{
    ReleaseSubsceneResources();
    mWindowRenderTarget.Reset();
    mWindowBackbuffer.Reset();
    mCommandBuffer.Reset();
    mRendererDevice = nullptr;
}
